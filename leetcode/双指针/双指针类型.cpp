
#include<iostream>
#include<vector>
#include<functional>
#include<algorithm>
#include<limits.h>
#include<string>
#include<unordered_map>
using namespace std;

#if 0
//1.双指针类题目
/***********************************************************************************************
373. Partition Array by Odd and Even
把一个数组划分为奇数在前偶数在后的状态，要求in place。
很简单，就用双指针法，让两个指针从两头往中间扫描，当左边是偶数右边是奇数时就交换，直到左右指针相遇为止。
***********************************************************************************************/
void partitionArray(vector<int> nums) {
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        // 左边是奇数的话就自增，直到找到前面的偶数
        while (nums[left] % 2 == 1) {
            left++;
        }
        // 右边是偶数的话就自减，直到找到后面的奇数
        while (nums[right] % 2 == 0) {
                right--;
        }
        if (left < right && nums[left] % 2 == 0 && nums[right] % 2 == 1) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
        }
    }
    return;
}
/***********************************************************************************************
539. Move Zeroes
把一个数组的所有0移动到末尾，且不改变原数组非零元素之间的相对位置。要求in place进行。
第一种方法是双指针移动法，left和right指针一开始都置为起始元素，然后让right去遍历寻找非0元素。找到了非0元素后，
就把两个指针的元素互换，使得后面的right指向的非0元素可以把left指向的0给替换掉。
交换完后，此时的left应该指向下一个0元素，所以left要自增。同时外层循环让right自增，继续去寻找下一个非0元素：
***********************************************************************************************/
void moveZeroes(vector<int> nums) {
    int left = 0, right = 0;
    while (right < nums.size()) {  // right从有边界开始找，找到往左边界填充
        // right指针找到一个非0的数，就与left指针交换
        if (nums[right] != 0) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            // 交换后，left自增
            left++;
        }
        right++;
    }
    return;
}
/***********************************************************************************************
172. Remove Element
给定一个数组和一个整数elem，要求把数组中所有等于elem的元素都删除，并返回新数组的长度。
比如：Given an array [0,4,4,0,0,2,4,4], value=4 return 4 and front four elements of the array is [0,0,0,2]
这道题的解法和上道题的方法二是一模一样的。双指针压缩法，把所有不等于elem的元素往前压缩：
***********************************************************************************************/
int removeElement(vector<int>  A, int elem) {
    int pos = 0;  // 左边界坐庄
    for (int i = 0; i < A.size(); i++) {
        if (A[i] != elem) { //有边界干活
            A[pos++] = A[i];  
        }
    }
    return pos;
}
/***********************************************************************************************
100. Remove Duplicates from Sorted Array
给定一个有序数组，要求去除其中重复的元素。与其说是删除重复元素，倒不如说是把unique的元素全部放到前面。
这道题跟上面两道题有异曲同工之妙，基本思路是一致的。双指针压缩法。我把所有unique的元素尽量往前面放。
左指针pos用于放置元素，右指针i用于从前往后扫描。当扫到一个跟pos不同的元素时，我就可以把它放到pos后面。
直到扫描完最后一个元素，这个时候数组的前pos+1个元素就是不包含重复元素的原数组的压缩版了：
***********************************************************************************************/
int removeDuplicates(vector<int> nums) {
    if (nums.size() == 0) {
        return 0;
    }
    int pos = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != nums[pos]) {
            pos++;
            nums[pos] = nums[i];
        }
    }
    return pos + 1;
}

/***********************************************************************************************
101. Remove Duplicates from Sorted Array II
跟上道题不同之处在于允许2次重复的出现。但是重复超过2次就不行了。基本思路还是一样的。
pre指针用于记录位置值以及放置unique元素，cur指针用于遍历，搜索与pre不同的元素。由于允许出现2次重复，所以需要一个变量count来统计重复次数。
因为数组是有序的，所以可以从前往后遍历的同时记录count。
如果cur和pre不同，则结束计数器(即count置为1)，同时把后面那个跟pre不同的元素(即cur)移动到pre的后面。然后把pre指向下一个元素。
如果cur和pre相同，并且此时还可以继续计数，则统计重复次数(即count++)。并且把cur移动到pre的后面。然后把pre指向下一个元素。
外层循环则继续移动cur指针来遍历
***********************************************************************************************/
int removeDuplicates(vector<int> &nums) {
    if (nums.size() == 0) {
        return 0;
    }
    int pre = 0, count = 1;
    for (int cur = 1; cur < nums.size(); cur++) {  // cur一直++
        // 前后两元素不相等，
        if (nums[cur] != nums[pre]) {  
            count = 1;   //计数1个还是2个
            nums[++pre] = nums[cur];
        } else {
            if (count < 2) { //如果相等，
                nums[++pre] = nums[cur];
                count++;  
            }
        }
    }
    return pre + 1;
}

/***********************************************************************************************
387. The Smallest Difference
给定两个数组，要求在这两个数组里找到两个数的差，使得两数之差最小。最直观的方法是两层循环逐个去遍历，时间复杂度是O(N*N)。
但是我们可以通过排序+双指针把时间复杂度降到O(N*logN)。先把两个数组排好序。然后同时从两个数组的起始位置往后扫描记录最小差。
哪个数字小，就先移动那个数组的遍历指针，以减少两数之差的距离。O(m+n)
***********************************************************************************************/
int smallestDifference(vector<int> &numsA, vector<int> &numsB) {
    if (numsA.size() == 0 || numsB.size() == 0) {
        return 0;
    }
    sort(numsA.begin(),numsA.end());
    sort(numsB.begin(),numsB.end());
    int min_ =  INT_MAX;  
    int i = 0, j = 0;
    while (i < numsA.size() && j < numsB.size()) {
        min_ = min(min_, abs(numsA[i] - numsB[j])); //记录其差值，保存最小的差值
        if (numsA[i] < numsB[j]) {
            i++;
        } else {
            j++;
        }
    }
    return min_;
}
/***********************************************************************************************
383. Container With Most Water
给定一个代表容器边界高度的数组，求最大的装水量。
容器装水量的多少取决于最短的那块木板的高度。这道题用双指针法，left和right指针从两边往中间遍历，left和right中较矮的那个就是当前木桶的高度，
计算当前木桶容量。
然后比较left和right谁高些，就把矮的那个指针往高指针的方向挪动一位，直到两个指针相遇为止。中途用max逐个比较记录最大木桶容量。
***********************************************************************************************/
int maxArea(vector<int>  heights) {
    int left = 0, right = heights.size() - 1;
    int max_ = 0;
    while (left < right) {
        int area = (right - left) * min(heights[left], heights[right]);
        max_ = max(area, max_);
        if (heights[left] < heights[right]) {
            left++;
        } else {
            right--;
        }
    }
    return max_;
}
//1.滑动窗口类题目
/***********************************************************************************************
这道题给定了我们一个数字，让我们求子数组之和大于等于给定值的最小长度。
我们需要定义两个指针left和right，分别记录子数组的左右的边界位置，然后我们让right向右移，直到子数组和大于等于给定值或者right达到数组末尾。
然后我们更新最短距离，并且将left像右移一位，然后把left左边的那个元素从sum中减去。
然后重复上面的步骤，直到right到达末尾。
没有排序的子数组
***********************************************************************************************/
int minimumSize(vector<int> nums, int target) {
    if (nums.size() == 0) {
        return -1;
    }
    int left = 0, right = 0;
    int minLength = INT_MAX;
    int sum = 0;
    
    for (left = 0; left < nums.size(); left++) {
        while (right < nums.size() && sum < target) {
            sum += nums[right];
            right++;
        }
        if (sum >= target) {// 更新最小长度，如果没找到那么 minLength = INT_MAX
            minLength = min(minLength, right - left);
        }
        sum -= nums[left];// 缩小左边界
    }
    
    return (minLength != INT_MAX) ? minLength : -1;
}

/***********************************************************************************************
386. Longest Substring with At Most K Distinct Characters
给定一个字符串，求它的最长子串，这个子串最多只能有K个不同的字符。跟上题类似，只不过要把HashSet换成HashMap了。

***********************************************************************************************/

    int lengthOfLongestSubstringKDistinct(string s, int k) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            ++m[s[i]];             //统计s[i]出现的次数
            while (m.size() > k) {
                if (--m[s[left]] == 0) 
                    m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
#endif


/***********************************************************************************************

***********************************************************************************************/




/***********************************************************************************************

***********************************************************************************************/




/***********************************************************************************************

***********************************************************************************************/




/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/





/***********************************************************************************************

***********************************************************************************************/




/***********************************************************************************************

***********************************************************************************************/





